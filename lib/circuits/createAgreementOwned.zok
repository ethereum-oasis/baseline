import "utils/pack/u32/nonStrictUnpack256" as unpack256
import "ecc/edwardsCompress" as edwardsCompress
import "hashes/sha256/1024bit" as shaOf1024Bits
import "utils/casts/bool_256_to_u32_8" as bool_256_to_u32_8
import "./helpers/conversion/field_2_to_u32_8" as field_2_to_u32_8
import "./proveOwnershipOfSk" as proveOwnershipOfSk

from "./types" import Commitment
from "./types" import Metadata
from "./types" import Agreement

def main(field publicInputHash, field[2] pk, private Commitment inputCommitment, private Metadata inputMetadata, private field sk) -> Agreement:
  u32[8] publicInputHashBits = unpack256(publicInputHash)

  // hash of the below private inputs must be equal to public input
  // Convert inputs to u32
  u32[8] saltBits = field_2_to_u32_8(inputCommitment.salt)
  u32[8] valueBits = field_2_to_u32_8(inputCommitment.value)
  bool[256] compressedSenderPubKey = edwardsCompress(inputMetadata.senderPublicKey)
  u32[8] pubKeyBits = bool_256_to_u32_8(compressedSenderPubKey)
  u32[8] nameBits = unpack256(inputMetadata.agreementName)
  u32[8] urlBits = unpack256(inputMetadata.agreementUrl)

  // compute hash
  u32[8] agreementHash = shaOf1024Bits(saltBits, pubKeyBits, nameBits, urlBits)

  // Check: Compare final hash to public input hash; and Compare input
  bool out = publicInputHashBits == agreementHash && valueBits == agreementHash

  // Check: Prove ownership of agreement
  bool owned = proveOwnershipOfSk(pk, sk)

  // Prepare output object
  Agreement outputAgreement = Agreement { hash: agreementHash, senderPublicKey: inputMetadata.senderPublicKey }

  // To consider:
  // - Formalize agreement struct based on baselineagreement.zok
  // - Pending issue to be resolved: struct within struct unwrapping
  // - Merkle root check
  return outputAgreement
